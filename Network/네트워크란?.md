# 서버
**'서버'** 란 도대체 어떤 것일까? 추상적으로 무엇인지를 알고 있겠지만, 우선은 사전적인 정의를 알아보는 것이 필요하겠다.
> ### 서버[Server]
> 1. 테니스, 탁구, 배구 등 서버를 하는 쪽, 또는 그 사람
> 2. 음식물을 제공하기 위해 사용하는 도구
> 3. 네트워크에서 다른 컴퓨터나 소프트웨어와 같은 클리이언트에게 서비스를 제공하는 컴퓨터


<div  align="center">
  
  
### 컴퓨터에게 서버는 클라이언트 에게 서비스를 제공한다.
</div>

서버는 '제공한다'는 뜻을 가진 'serve'에 사람이라는 뜻으로 나타내는 'er'을 붙인 단어이다. 위에 사전의 뜻을 보면 공통적으로 
뭔가를 제공한다는 것을 알 수 있다. 컴퓨터에서는 **서버는 클라이언트에게 여러 가지 서비스를 제공하는 것을 뜻한다.**

감이 잘 안온다면, 간단한 예를 들어보자. 평소에 우리는 웹 브라우저를 사용해 웹사이트에 액세스하고 있을 것이다.
이때 웹 브라우저가 '클라이언트'이며, 웹 사이트의 콘텐츠가 있는 컴퓨터가 '서버'이다.

<div align="center">

  <img  width="40%"  src ="https://user-images.githubusercontent.com/41848169/147564407-ed6bd82c-6a96-4298-a333-ecfe467d38e0.png"/>
  

</div>

# 클라이언트/ 서버 시스템

서버는 단독으로 움직이지 않으며 불특정 다수의 컴퓨터에 일방적으로 서비스를 제공하는 것도 아니다.
서버는 **클라이언트로부터 요청(Request)를 받아야 비로소 처리를 시작하여 서비스를 제공**한다. 서버가 클라이언트에게 서비스를 제공할 때 다음과 같은 처리가 일어난다.

> 1. 클라이언트가 서버에게 어떤 서비스를 요청
> 2. 서버는 요청에 응답해 처리를 수행
> 3. 서버는 처리 결과를 클라이언트에게 반환
> 4. 클라이언트는 처리 결과를 받음

이를 이해하기 쉽게 브라우저(크롬이나 사파리 등)에 적용하면 다음과 같다

> 1. 웹 브라우저가 웹 서버에게 'www.naver.com' 사이트 데이터를 달라고 요청
> 2. 웹 서버는 해당 사이트의 파일을 찾음
> 3. 웹 서버는 찾은 파일 웹 브라우저에게 반환
> 4. 웹 브라우저는 파일 받아 네이버 메인을 화면에 표시

<div align="center">
  
  
![image](https://user-images.githubusercontent.com/41848169/147564612-8f70a7af-c558-4d56-82ae-20d1d75dcab0.png)

</div>



이처럼 서버와 클라이언트로 구성된 시스템을 '클라이언트/서버 시스템'이라고 한다. 클라이언트/서버 시스템은 서버에서 데이터를 쉽게 관리할 수 있기 때문에 대부분 컴퓨터 시스템에서
 채택하고 있다.
 
 # 여러 가지 서버
 
 **서버의 역할을 서비스에 의해 정해진다.** 우리가 인터넷을 통해 제공받고 있는 모든 정보가 서비스라고 할 수 있다. 예를들어 매일 사용하는 웹 사이트나 메일 그리고 카카오톡, 트위터, 
 페이스북 모두 서비스이다.
 
 우리는 자기도 모르는 사이에 수많은 서비스를 서버로부터 인터넷을 통해 제공받고 있다.
 
 이처럼 컴퓨터 세계에는 셀 수 없을 정도로 많은 서비스가 존재하고 그 수만큼 서버의 역할이 있다. 서버의 역할에 대해 이야기 할 대는 'XX 서버'와 같이 서비스
 이름을 그대로 서버 앞에 붙여보자. (카카오톡 서버, 페이스북 서버, 웹 서버 등)
 
 사람에 따라 웹 서버를 HTTP ㅛㅓ버라고 부르거나 메일 서버 SMTP 서버라고 부르는 경우도 있다. **이는 사람에 따라 서비스를 부르는 호칭안 개념이 다소 다를 뿐 본질적으로 크게 다른 것이 아니다.**
 
 ![image](https://user-images.githubusercontent.com/41848169/147566063-3435d26c-b16d-4da6-bfb2-228d8650e54a.png)
 
 # 서버 소프트웨어
 
 서버 구축은 생각보다 간단하다. 그냥 컴퓨터에 소프트웨어를 설치하고 실행시키면 된다. 결국 서버란 것도 서비스를 제공하기 위한 소프트웨어인 **'서버 소프트웨어'**가 가지고 있는 기능 자체를 뜻하는 것이다.
 
 ![image](https://user-images.githubusercontent.com/41848169/147566145-4a8a6657-04be-44e9-8767-334c3ecd8b44.png)


서버 소프트웨어는 서비스를 제공하기 위한 기능을 가진 소프트웨어이므로 서비스별로 서버 소프트웨어가 있다고 생각하면 된다. 에를 들어 
웹 서비스를 제공하는 소프트웨어는 '웹 서버 소프트웨어'이며, 그것이 작동하고 있는 컴퓨터가 바로 '웹 서버'이다. 메일 서비스를 제공한다면 '메일 서버 소프트웨어'. 작동되는 컴퓨터는 '메일 서버'가 된다.
![image](https://user-images.githubusercontent.com/41848169/147566289-bfe09c73-d227-4a72-924d-810d6d975134.png)

서버는 결국 '서버 소프트웨어가 제공하는 기능'을 뜻하는 것이다. 따라서 컴퓨터에서 작동하는 응용 프로그램들과 마찬가지로 **한 대의 컴퓨터에 여러 개의 서버 소프트웨어를 작동**시킬 수 있다.
규모에 따라 다르겠지만, 각 서비스를 한 컴퓨터에서만 서버로 제공하는 것이 비효율적일 수 있다. 한정된 물리적 자원을 효율적으로 사용하는 것도 서버 구축 및 우녕의 핵심 과제 중 하나라고 할 수 있다.

# 기업에 있어서의 서버

실제로 네트워크 시스템을 구축할 때는 수많은 서버 중 어떤 서버를 선택하는 것이 좋을까? 이 질문에 대한 가장 간단한 답변은 **'사용자와 시스템의 목소리에 귀를 기울여라'** 라는 것이다. 결국 모든 해답은 '요구'안에 들어 있기 때문이다.
예를 들어 인터넷에 연결하고 싶다는 요구가 있는 경우 도메인명을 IP로 변환하는 서비스를 제공하는 DNS 서버가 필요하다. 그리고 모든 사람과 데이터를 공유하고 싶다라는 요구가 있는 경우에는
 데이터를 관리할 파일 서버가 필요하다.**사용자와 시스템 요구 사항들을 잘 정의하면 어떤 서버를 구축해야 할지 답이 보일 것이다.**
 ![image](https://user-images.githubusercontent.com/41848169/147566578-679561c8-70b3-4fde-9d44-6c0d28b59d16.png)

 # 서버의 운용 관리
 
 구축이 끝난 서버는 서비스를 시작함과 동시에 운용 관리에 들어간다. 운용 관리는 서비스 종료 시까지 계속 이어진다.
 서버 운용 관리는 **'설정 변경'**과 **'트러블 대처'** 라는 두 가지 주요 작업을 수행한다.
 
 ### 설정 변견
 서버 관리자는 사용자 요구에 맞춰 서버 설정을 변경해 간다. 서버를 운용 관리하다 보면 반드시 여러 요구사항이 나오기 마련이기 때문이다. 하지만 
 모든 요구를 다 들어주는 것은 현실적으로 불가능하기 때문에 한정된 설정 항목으로 구성된 요구 사항표 등을 미리 만들어 두고 **설정할 범위를 좁혀 두는 나중에 관리하기 더 수월해진다.**
 
 ### 트러블 대처
 트러블 대처는 크게 **'사전 대처'** 와 **'사후 대처'** 로 나뉜다.
 
 사전 대처는 트러블을 예빵하기 위한 것으로, 여기서는 서버의 각종 상태(CPU, 메모리 사용률, 통신 상태, 오류 로그 등)를 정기적으로 체크한다. 이를 통해 이상이 감지되면 그 상세 내역을 확힌하고 경우에 따라 트러블 예빵을 위한 서버 교체 등을 실시하낟.
 
 그에 반해 사후 대처는 트러블일 일어난 후의 대처를 뜻한다. 서버는 장애가 발생하기 마련으로, 언젠가 반드시 고장이 일어난다. 사후 대처에서는 구체적으로 서버 어디에 어떤 장애가 발생했는지를 오류 로그 등으로 확힌하고 장애에 대한 적절한 처리 수행한다. 사후 처리는 스피드가 관건이기 때문에 **서버 구축시에 미리 여러 패턴의 장애 테스트를 실시하고 장애 대처 방법을 시뮬레이션해 두는 것이 좋다.**

# 서버와 네트워크
서버와 클라이언트가 서로 통신할 수 있게 다리 역할을 하는 기술이 '네트워크'이다. 모든 서버는 네트워크를 통해 데이터를 제공한다. 서버는 네트워크에 연결되어 있지 않다면 데이터를 제공할 수 없으며, 클라이언트도 마찬가지로 데이터를 받을 수 없게 된다.



네트워크는 '뭔가와 뭔가의 연결' 전반을 뜻하낟. 예를 들어 역과 역을 연결하는 철도 노선이나 방송국과 방송국을 연결하는 방송망도 네트워크이며, 회사나 조직 등에서 사람과 사람과의 연결도 네트워크이다. 여기서의 네트워크는 컴퓨터와 컴퓨터를 연결하는 것을 가리킨다. 철도 노선 네트워크는 전철이 승객을 싣고 나르듯 컴퓨터 네트워크는 데이터를 케이블(혹은 전파)에 실어 나른다.

![image](https://user-images.githubusercontent.com/41848169/147567822-8726892f-dff7-4970-8949-9d1c3c493a9a.png)

 컴퓨터 네트워크에는 구체적으로 어떤 것이 있는지 좀더 세분화하여 살펴보자. 우리 주변에서 자주 듣는 말로 '인터넷'이 있다. 인터넷이라는 말의 기원은 '인터네트워크(Internetwork)'로, 전 세계에 산재해 있는 네트워크를 연결하는 거대한 네트워크를 뜻한다. 'LAN'이라는 말도 많이 들어봤을 것이다. LAN은 '로컬 영역 네트워크(Local ARea Netowrk)'의 약자로, 기업이나 조직 등 비교적 좁은 범위 안에 존재하는 컴퓨터를 연결하는 네트워크를 뜻하낟. LAN 케이블은 이러한 LAN을 연겨랗는 위한 매체이며, LAN 스위치는 LAN을 구성하기 위한 네트워크 기기이다.
 
 
![image](https://user-images.githubusercontent.com/41848169/147567967-4a8ffac0-4ac5-4226-afc1-90ec67645ca1.png)

# 네트워크 기술 이해하기

일반적으로 말하는 LAN은 크게 LAN 케이블을 이용하여 데이터를 전송하는 '유선 LAN'과 전파를 이용하여 데이터를 전송하는 '무선 LAN'으로 나눌 수 있다. 이중 서버를 연결할 때는 유선 LAN을 
사용하는 것이 기본이다. 왜냐하면 아무리 고속의 무선 LAN이라 할지라도 속도나 품질 면에서 유선 LAN을 따라오려면 아직 멀었기 때문이다. **무선 LAN은 아직까지는 클라이언트측만을 위한 것이다.**

![image](https://user-images.githubusercontent.com/41848169/147635853-bbeb663d-d540-4667-a73b-632fb534e7f9.png)

# OSI 참조 모델과 프로토콜

네트워크를 학습할 때 가장 먼저 이해해야 하는 개념은 'OSI 참조 모델'이다. OSI(Open System Interconnection)참조 모델은 국제표준화기구(ISO)가 컴퓨터의 통신 기능을 계층 구조로 나눠서 정리한
 모델로, 쉽게 말하면 **'통신할 때의 규칙의 모음'** 과 같은 것이다. 네트워크에서는 이러한 규칙을 **'프로토콜'** 이라고 부른다. 예를 들면 우리가 웹 사이트를 볼때
 URL 앞에 http를 입력할 것이다. 여기서 'http'가 프로토콜에 해당하낟. HTTP는 Hyper Text Transfer Protocol의 약자로, 웹 서버와 웹 클라이언트에서 데이터를 송수신 할때 사용하는 
 통신 프로토콜이다.
 
 
 
 OSI 참모 모델에서는 프로토콜을 (anffl rPCmd[1], 데이터 링크 계층[2], 네트워크 계층[3], 전송 계층[4], 세션 계층[5], 표현 계층[6], 응용 계층[7]) 총 7계층으로 분류한다. 각각의 계층은 전혀 다른 역할을 하고 가지고 있으며 따로따로 작동하도록 되어 있다. 이를 통해 계층들이 서로 영향을 받지 않으며 계층 별로 분리된 트러블 슈팅을 할 수 이싿.
 
 
 
 OSI참조 모델은 많은 프로토콜로 구성되어 있지만 **실제 네트워크에서 사용하는 프로토콜을 극히 일부로, 상당히 한정되어 있다.** 제 1, 2 계층에서는 '이더넷', 제 3계층은 'IP', 'ICMP', 'ARP', 제 4계층은 'TCP', 'UDP'. 그리고 제 5계층부터 제 7계층은 '애플리케이션 프로토콜'을 사용한다.
 
 
 # 프로토콜의 역할
 프로토콜이 가지고 있는 역할 중 가장 중요한 것이 **'캡슐화'** 와 **'캡슐 해체화'** 이다. 네트워크 통신에서는 OSI 참조 모델의 계층을 넘어설 때마다 데이터를 캡슐에 넣고 꺼낸다. 캡슐화와 캡슐 해체화는 어플리케이션 데이터를 보내는 서버와 그것을 받는 클라이언트를 예로 생각하면 쉽게 이해할 수 있다
 
 
![image](https://user-images.githubusercontent.com/41848169/147636430-f3afca9f-3ef3-4b66-8ab1-b22ce834745d.png)

위의 그림을 보면 서버에서 실행하는 처리가 캡슐화이다. **서버는 상위 계층에서부터 하위 계층으로 캡슗화 처리를 하여 전송용 데이터를 만들어 간다.** 서버는 가공한 서버 애플리케이션 데이터를 전송 계층에 전달한다. 전송 계층에서는 이 데이터를 TCP/UDP 세그먼트에 넣어 네트워크 계층으로 전달한다. 네트워크 계층은 받은 세그먼트를 IP패킷에 넣어 데이터링크 계층으로 전달한다. 데이터 링크 계층은 패킷을 이더넷 프레임에 넣어 물리 계층으로 전달한다. 물리 계층에서는 받은 프레임을 신호로 보내기 좋은 비트로 변환시킨 후 전기나 광 신호로 만들어 보낸다.



이와 반대로 클라이언트에서 실해하는 처리가 캡슐 해제화이다. **클라이언트는 하위 계층에서부터 상위 계층으로 캡슐 해제화 처리를 하여 원래의 어플리케이션 데이터로 되돌려 간다.** 물리 계층에서 신호를 받으면 비트로 변환한 후 프레임을 만들어 데이터링크 계층으로 전달한다. 데이터링크 계층은 프레임에서 패킷을 꺼내 네트워크 계층으로 전달한다. 네트워크 계층은 패킷에서 세그먼트를 꺼내 전소 계층으로 전달한다. 전송 계층은 세그먼트에서 데이터를 꺼내 클라이언트 애플리케이션에게 전달한다.

# 이더넷과 MAC주소
제 1, 2ㄱ 계층에서 필수불가결한 규격이 '이더넷'이다. 유선 네트워크의 거의 대부분은 이더넷을 사용하고 있다. 이더넷은 네트워크 계층으로부터 받은 패킷에 프레임을 

 
 
