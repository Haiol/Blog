# 서버
**'서버'** 란 도대체 어떤 것일까? 추상적으로 무엇인지를 알고 있겠지만, 우선은 사전적인 정의를 알아보는 것이 필요하겠다.
> ### 서버[Server]
> 1. 테니스, 탁구, 배구 등 서버를 하는 쪽, 또는 그 사람
> 2. 음식물을 제공하기 위해 사용하는 도구
> 3. 네트워크에서 다른 컴퓨터나 소프트웨어와 같은 클리이언트에게 서비스를 제공하는 컴퓨터


<div  align="center">
  
  
### 컴퓨터에게 서버는 클라이언트 에게 서비스를 제공한다.
</div>

서버는 '제공한다'는 뜻을 가진 'serve'에 사람이라는 뜻으로 나타내는 'er'을 붙인 단어이다. 위에 사전의 뜻을 보면 공통적으로 
뭔가를 제공한다는 것을 알 수 있다. 컴퓨터에서는 **서버는 클라이언트에게 여러 가지 서비스를 제공하는 것을 뜻한다.**

감이 잘 안온다면, 간단한 예를 들어보자. 평소에 우리는 웹 브라우저를 사용해 웹사이트에 액세스하고 있을 것이다.
이때 웹 브라우저가 '클라이언트'이며, 웹 사이트의 콘텐츠가 있는 컴퓨터가 '서버'이다.

<div align="center">

  <img  width="40%"  src ="https://user-images.githubusercontent.com/41848169/147564407-ed6bd82c-6a96-4298-a333-ecfe467d38e0.png"/>
  

</div>

# 클라이언트/ 서버 시스템

서버는 단독으로 움직이지 않으며 불특정 다수의 컴퓨터에 일방적으로 서비스를 제공하는 것도 아니다.
서버는 **클라이언트로부터 요청(Request)를 받아야 비로소 처리를 시작하여 서비스를 제공**한다. 서버가 클라이언트에게 서비스를 제공할 때 다음과 같은 처리가 일어난다.

> 1. 클라이언트가 서버에게 어떤 서비스를 요청
> 2. 서버는 요청에 응답해 처리를 수행
> 3. 서버는 처리 결과를 클라이언트에게 반환
> 4. 클라이언트는 처리 결과를 받음

이를 이해하기 쉽게 브라우저(크롬이나 사파리 등)에 적용하면 다음과 같다

> 1. 웹 브라우저가 웹 서버에게 'www.naver.com' 사이트 데이터를 달라고 요청
> 2. 웹 서버는 해당 사이트의 파일을 찾음
> 3. 웹 서버는 찾은 파일 웹 브라우저에게 반환
> 4. 웹 브라우저는 파일 받아 네이버 메인을 화면에 표시

<div align="center">
  
  
![image](https://user-images.githubusercontent.com/41848169/147564612-8f70a7af-c558-4d56-82ae-20d1d75dcab0.png)

</div>



이처럼 서버와 클라이언트로 구성된 시스템을 '클라이언트/서버 시스템'이라고 한다. 클라이언트/서버 시스템은 서버에서 데이터를 쉽게 관리할 수 있기 때문에 대부분 컴퓨터 시스템에서
 채택하고 있다.
 
 # 여러 가지 서버
 
 **서버의 역할을 서비스에 의해 정해진다.** 우리가 인터넷을 통해 제공받고 있는 모든 정보가 서비스라고 할 수 있다. 예를들어 매일 사용하는 웹 사이트나 메일 그리고 카카오톡, 트위터, 
 페이스북 모두 서비스이다.
 
 우리는 자기도 모르는 사이에 수많은 서비스를 서버로부터 인터넷을 통해 제공받고 있다.
 
 이처럼 컴퓨터 세계에는 셀 수 없을 정도로 많은 서비스가 존재하고 그 수만큼 서버의 역할이 있다. 서버의 역할에 대해 이야기 할 대는 'XX 서버'와 같이 서비스
 이름을 그대로 서버 앞에 붙여보자. (카카오톡 서버, 페이스북 서버, 웹 서버 등)
 
 사람에 따라 웹 서버를 HTTP ㅛㅓ버라고 부르거나 메일 서버 SMTP 서버라고 부르는 경우도 있다. **이는 사람에 따라 서비스를 부르는 호칭안 개념이 다소 다를 뿐 본질적으로 크게 다른 것이 아니다.**
 
 ![image](https://user-images.githubusercontent.com/41848169/147566063-3435d26c-b16d-4da6-bfb2-228d8650e54a.png)
 
 # 서버 소프트웨어
 
 서버 구축은 생각보다 간단하다. 그냥 컴퓨터에 소프트웨어를 설치하고 실행시키면 된다. 결국 서버란 것도 서비스를 제공하기 위한 소프트웨어인 **'서버 소프트웨어'**가 가지고 있는 기능 자체를 뜻하는 것이다.
 
 ![image](https://user-images.githubusercontent.com/41848169/147566145-4a8a6657-04be-44e9-8767-334c3ecd8b44.png)


서버 소프트웨어는 서비스를 제공하기 위한 기능을 가진 소프트웨어이므로 서비스별로 서버 소프트웨어가 있다고 생각하면 된다. 에를 들어 
웹 서비스를 제공하는 소프트웨어는 '웹 서버 소프트웨어'이며, 그것이 작동하고 있는 컴퓨터가 바로 '웹 서버'이다. 메일 서비스를 제공한다면 '메일 서버 소프트웨어'. 작동되는 컴퓨터는 '메일 서버'가 된다.
![image](https://user-images.githubusercontent.com/41848169/147566289-bfe09c73-d227-4a72-924d-810d6d975134.png)

서버는 결국 '서버 소프트웨어가 제공하는 기능'을 뜻하는 것이다. 따라서 컴퓨터에서 작동하는 응용 프로그램들과 마찬가지로 **한 대의 컴퓨터에 여러 개의 서버 소프트웨어를 작동**시킬 수 있다.
규모에 따라 다르겠지만, 각 서비스를 한 컴퓨터에서만 서버로 제공하는 것이 비효율적일 수 있다. 한정된 물리적 자원을 효율적으로 사용하는 것도 서버 구축 및 우녕의 핵심 과제 중 하나라고 할 수 있다.

# 기업에 있어서의 서버

실제로 네트워크 시스템을 구축할 때는 수많은 서버 중 어떤 서버를 선택하는 것이 좋을까? 이 질문에 대한 가장 간단한 답변은 **'사용자와 시스템의 목소리에 귀를 기울여라'** 라는 것이다. 결국 모든 해답은 '요구'안에 들어 있기 때문이다.
예를 들어 인터넷에 연결하고 싶다는 요구가 있는 경우 도메인명을 IP로 변환하는 서비스를 제공하는 DNS 서버가 필요하다. 그리고 모든 사람과 데이터를 공유하고 싶다라는 요구가 있는 경우에는
 데이터를 관리할 파일 서버가 필요하다.**사용자와 시스템 요구 사항들을 잘 정의하면 어떤 서버를 구축해야 할지 답이 보일 것이다.**
 ![image](https://user-images.githubusercontent.com/41848169/147566578-679561c8-70b3-4fde-9d44-6c0d28b59d16.png)

 # 서버의 운용 관리
 
 구축이 끝난 서버는 서비스를 시작함과 동시에 운용 관리에 들어간다. 운용 관리는 서비스 종료 시까지 계속 이어진다.
 서버 운용 관리는 **'설정 변경'**과 **'트러블 대처'** 라는 두 가지 주요 작업을 수행한다.
 
 ### 설정 변견
 서버 관리자는 사용자 요구에 맞춰 서버 설정을 변경해 간다. 서버를 운용 관리하다 보면 반드시 여러 요구사항이 나오기 마련이기 때문이다. 하지만 
 모든 요구를 다 들어주는 것은 현실적으로 불가능하기 때문에 한정된 설정 항목으로 구성된 요구 사항표 등을 미리 만들어 두고 **설정할 범위를 좁혀 두는 나중에 관리하기 더 수월해진다.**
 
 ### 트러블 대처
 트러블 대처는 크게 **'사전 대처'** 와 **'사후 대처'** 로 나뉜다.
 
 사전 대처는 트러블을 예빵하기 위한 것으로, 여기서는 서버의 각종 상태(CPU, 메모리 사용률, 통신 상태, 오류 로그 등)를 정기적으로 체크한다. 이를 통해 이상이 감지되면 그 상세 내역을 확힌하고 경우에 따라 트러블 예빵을 위한 서버 교체 등을 실시하낟.
 
 그에 반해 사후 대처는 트러블일 일어난 후의 대처를 뜻한다. 서버는 장애가 발생하기 마련으로, 언젠가 반드시 고장이 일어난다. 사후 대처에서는 구체적으로 서버 어디에 어떤 장애가 발생했는지를 오류 로그 등으로 확힌하고 장애에 대한 적절한 처리 수행한다. 사후 처리는 스피드가 관건이기 때문에 **서버 구축시에 미리 여러 패턴의 장애 테스트를 실시하고 장애 대처 방법을 시뮬레이션해 두는 것이 좋다.**

# 서버와 네트워크
서버와 클라이언트가 서로 통신할 수 있게 다리 역할을 하는 기술이 '네트워크'이다. 모든 서버는 네트워크를 통해 데이터를 제공한다. 서버는 네트워크에 연결되어 있지 않다면 데이터를 제공할 수 없으며, 클라이언트도 마찬가지로 데이터를 받을 수 없게 된다.



네트워크는 '뭔가와 뭔가의 연결' 전반을 뜻하낟. 예를 들어 역과 역을 연결하는 철도 노선이나 방송국과 방송국을 연결하는 방송망도 네트워크이며, 회사나 조직 등에서 사람과 사람과의 연결도 네트워크이다. 여기서의 네트워크는 컴퓨터와 컴퓨터를 연결하는 것을 가리킨다. 철도 노선 네트워크는 전철이 승객을 싣고 나르듯 컴퓨터 네트워크는 데이터를 케이블(혹은 전파)에 실어 나른다.

![image](https://user-images.githubusercontent.com/41848169/147567822-8726892f-dff7-4970-8949-9d1c3c493a9a.png)

 컴퓨터 네트워크에는 구체적으로 어떤 것이 있는지 좀더 세분화하여 살펴보자. 우리 주변에서 자주 듣는 말로 '인터넷'이 있다. 인터넷이라는 말의 기원은 '인터네트워크(Internetwork)'로, 전 세계에 산재해 있는 네트워크를 연결하는 거대한 네트워크를 뜻한다. 'LAN'이라는 말도 많이 들어봤을 것이다. LAN은 '로컬 영역 네트워크(Local ARea Netowrk)'의 약자로, 기업이나 조직 등 비교적 좁은 범위 안에 존재하는 컴퓨터를 연결하는 네트워크를 뜻하낟. LAN 케이블은 이러한 LAN을 연겨랗는 위한 매체이며, LAN 스위치는 LAN을 구성하기 위한 네트워크 기기이다.
 
 
![image](https://user-images.githubusercontent.com/41848169/147567967-4a8ffac0-4ac5-4226-afc1-90ec67645ca1.png)

# 네트워크 기술 이해하기

일반적으로 말하는 LAN은 크게 LAN 케이블을 이용하여 데이터를 전송하는 '유선 LAN'과 전파를 이용하여 데이터를 전송하는 '무선 LAN'으로 나눌 수 있다. 이중 서버를 연결할 때는 유선 LAN을 
사용하는 것이 기본이다. 왜냐하면 아무리 고속의 무선 LAN이라 할지라도 속도나 품질 면에서 유선 LAN을 따라오려면 아직 멀었기 때문이다. **무선 LAN은 아직까지는 클라이언트측만을 위한 것이다.**

![image](https://user-images.githubusercontent.com/41848169/147635853-bbeb663d-d540-4667-a73b-632fb534e7f9.png)

# OSI 참조 모델과 프로토콜

네트워크를 학습할 때 가장 먼저 이해해야 하는 개념은 'OSI 참조 모델'이다. OSI(Open System Interconnection)참조 모델은 국제표준화기구(ISO)가 컴퓨터의 통신 기능을 계층 구조로 나눠서 정리한
 모델로, 쉽게 말하면 **'통신할 때의 규칙의 모음'** 과 같은 것이다. 네트워크에서는 이러한 규칙을 **'프로토콜'** 이라고 부른다. 예를 들면 우리가 웹 사이트를 볼때
 URL 앞에 http를 입력할 것이다. 여기서 'http'가 프로토콜에 해당하낟. HTTP는 Hyper Text Transfer Protocol의 약자로, 웹 서버와 웹 클라이언트에서 데이터를 송수신 할때 사용하는 
 통신 프로토콜이다.
 
 
 
 OSI 참모 모델에서는 프로토콜을 (anffl rPCmd[1], 데이터 링크 계층[2], 네트워크 계층[3], 전송 계층[4], 세션 계층[5], 표현 계층[6], 응용 계층[7]) 총 7계층으로 분류한다. 각각의 계층은 전혀 다른 역할을 하고 가지고 있으며 따로따로 작동하도록 되어 있다. 이를 통해 계층들이 서로 영향을 받지 않으며 계층 별로 분리된 트러블 슈팅을 할 수 이싿.
 
 
 
 OSI참조 모델은 많은 프로토콜로 구성되어 있지만 **실제 네트워크에서 사용하는 프로토콜을 극히 일부로, 상당히 한정되어 있다.** 제 1, 2 계층에서는 '이더넷', 제 3계층은 'IP', 'ICMP', 'ARP', 제 4계층은 'TCP', 'UDP'. 그리고 제 5계층부터 제 7계층은 '애플리케이션 프로토콜'을 사용한다.
 
 
 # 프로토콜의 역할
 프로토콜이 가지고 있는 역할 중 가장 중요한 것이 **'캡슐화'** 와 **'캡슐 해체화'** 이다. 네트워크 통신에서는 OSI 참조 모델의 계층을 넘어설 때마다 데이터를 캡슐에 넣고 꺼낸다. 캡슐화와 캡슐 해체화는 어플리케이션 데이터를 보내는 서버와 그것을 받는 클라이언트를 예로 생각하면 쉽게 이해할 수 있다
 
 
![image](https://user-images.githubusercontent.com/41848169/147636430-f3afca9f-3ef3-4b66-8ab1-b22ce834745d.png)

위의 그림을 보면 서버에서 실행하는 처리가 캡슐화이다. **서버는 상위 계층에서부터 하위 계층으로 캡슗화 처리를 하여 전송용 데이터를 만들어 간다.** 서버는 가공한 서버 애플리케이션 데이터를 전송 계층에 전달한다. 전송 계층에서는 이 데이터를 TCP/UDP 세그먼트에 넣어 네트워크 계층으로 전달한다. 네트워크 계층은 받은 세그먼트를 IP패킷에 넣어 데이터링크 계층으로 전달한다. 데이터 링크 계층은 패킷을 이더넷 프레임에 넣어 물리 계층으로 전달한다. 물리 계층에서는 받은 프레임을 신호로 보내기 좋은 비트로 변환시킨 후 전기나 광 신호로 만들어 보낸다.



이와 반대로 클라이언트에서 실해하는 처리가 캡슐 해제화이다. **클라이언트는 하위 계층에서부터 상위 계층으로 캡슐 해제화 처리를 하여 원래의 어플리케이션 데이터로 되돌려 간다.** 물리 계층에서 신호를 받으면 비트로 변환한 후 프레임을 만들어 데이터링크 계층으로 전달한다. 데이터링크 계층은 프레임에서 패킷을 꺼내 네트워크 계층으로 전달한다. 네트워크 계층은 패킷에서 세그먼트를 꺼내 전소 계층으로 전달한다. 전송 계층은 세그먼트에서 데이터를 꺼내 클라이언트 애플리케이션에게 전달한다.

# 이더넷과 MAC주소
제 1, 2 계층에서 필수불가결한 규격이 **'이더넷'** 이다. 유선 네트워크의 거의 대부분은 이더넷을 사용하고 있다. 이더넷은 네트워크 계층으로부터 받은 패킷에 프레임의 처음을 나타내는
 '프리앰플(preamble)'과 목적지와 출발지를 나타내는 '헤더', 비트 오류 체크에 사용하는 'FCS(Frame Check Sequence)'를 추가하여 프레임을 만든다.
 ![image](https://user-images.githubusercontent.com/41848169/147654772-a0354d0d-389a-4234-a273-82820362fd26.png)
이데넷은 'MAC 주소'리는 48비트로 된 실별자를 사용하여 컴푸터를 식별한다.
>a8:66:7f:04:00:80
>00-50-56-c0-00-01

MAC 주소는 위와 같이 8비트마다 하이픈이나 콜론으로 구분하여 16진수로 표기하는데, 상위 24비트와 하위 24비트가 각각 다른 뜻을 가진다. 상위 24비트는 미국전기전자학회가 제조업체별로 할당한
코드이다. 이를 OUI(Prganizationally Unique Identifier)라고 하는데, 이 부분을 보면 제조업체를 알 수 있다. 하위 24비트는 제조업체에서 기기별로 고유한 값으로 할당한 코드이다.
이런 구조로 이루어져 있기에, 각 기기에 할당되는 MAC 주소는 전 세계에서 하나 밖에 없는 고유한 값이 될 수 있다.

# 스위칭

이더넷은 '스위치'리는 네트워크 기기를 중심으로 하여 컴퓨터를 배치해 가는 '스타형 토폴로지' 연결 형태를 채택하고 있다.

유선 네트워크의 경우 컴퓨터 LAN 케이블을 경유해 스위치에 연결되어 있다.

![image](https://user-images.githubusercontent.com/41848169/147655108-08292ab2-2b1b-4a3c-a3d0-c5d95bf2a393.png)

스위치는 프레임(제 2계층 데이터)이 들어온 'LAN 포트 번호'와 그 프레임의 '출발지 MAC 주소'를 테이블(대응표)로 만들어 일정 기간 동안 기억해 둔다. 이를 통해 불필요한 프레임 전송을 막고 이더넷 네트워크의 통신 효율을 향상시킨다. 스위치가 수행하는 프레임 전송을 '스위칭'이라고 하며, 스위칭에서 사용하는 LAN 포트 번호와 출발지 MAC 주소 테이블을 'MAC 주소 테이블'이라고 한다. 스위치는 다음과 같은 순서로 테이블을 만들어 필요한 포트에게만 프레임을 전송하도록 하고 있다.

<pre>
1. 프레임을 받은 스위치는 프레임의 LAN 포트 번호와 출발지 MAC 주소를 테이블에 기록
2. 목적지 MAC 주소 정보가 테이블에 있으면 그 정보를 바탕을 ㅗ프레임을 전송, 없으면 모든 포트에게 프레임의 복사본을 송신하는데, 
이때 해당되는 컴퓨터만 프레임을 수취하고 그 외의 컴퓨터는 프레임을 파기.

3. 그 후는 프레임이 들어올 때마다 MAC주소 테이블의 정보를 갱신. 더 이상 사용하지 않는 정보는 일정 시간이 경과하면 삭제
</pre>
![image](https://user-images.githubusercontent.com/41848169/147658576-23b94b9d-0407-4421-9886-e1d75940a46f.png)

# IP와 IP주소
제 3계층에서 가장 중요한 프로토콜은 'IP(Internet Protocol)'이다. 오늘날의 네트워크는 거의 대부분 IP를 사용한다.
IP는 제 4계증(전송 계층)으로부터 받은 세그먼트에 'IP 헤더'를 붙여 패킷으로 만든다. IP 헤더는 패킷의 목적지를 나타내는 택배 전표와 같다.
패킷은 바다 밑부터 산속까지 전 세계의 모든 네트워크를 경유하기 때문에 IP 헤더는 그러한 환경 차이를 흡수할 수 있도록 많은 필드로 구성되어 있다.

![image](https://user-images.githubusercontent.com/41848169/147658785-0fa75243-e23a-40a3-a591-1cc1d7cdd524.png)

![image](https://user-images.githubusercontent.com/41848169/147821865-685e6672-5627-47bc-ac72-d2d4a621999e.png)

IP는 'IP 주소'라는 32비트로 된 실별번호를 사용하여 컴퓨터를 식별한다.IP주소는 '192.168.1.1'같이 8비트마다 점으로 구분하여 10진수로 표기한는데, 
점으로 구분된 그룹을 '옥텟'이라고 하며, 맨 처음부터 제 1 옥텟, 제 2 옥텟 등과 같이 부른다.

IP 주소는 단독으로 사용하는 것이 아닌 '서브넷 마스크'라는 32비트로 된 값과 세트로 사용한다. IP 주소는 서브넷 마스크로 분할된 '네트워크부'와 '호스트부로 구성되어 있다. 네트워크부는 네트워크 자체를 나타내고 있으며, 호스트부는 해당 네트워크에 연결되어 있는 단말을 나타내고 있다. 서브넷 마스크는 이둘을 구분하는 표식과 같은 것으로, '1'이 네트워크부, '0'이 호스부를 나타내고 있다.

서브넷 마스크는 '10진수 표기'와 'CIDR 표기' 라는 2종류의 표기 방법이 있다. 10진수 표기에서는 IP 주소처럼 32비트를 7비트씩 4개의 
그룹으로 나눈 후 각각을 10진수로 변환하여 점으로 구분하여 표기한다. CIDR 표기에서는 IP주소 다음에 슬래시와 '1'의 개수를 추가하여 표기한다.

예를 들어 '72.16.1.1'이라는 IP 주소에 '255.255.0.0'이라는 서브넷 마스크가 설정되어 있다면 '172.16.1.1/16'으로 표기하는데 이로써 '172.16'이라는 네트워크의 '1.1'이라는 호스트라는 것을 알 수 있다.

![image](https://user-images.githubusercontent.com/41848169/147822062-e1771bf1-26b2-4e18-bc54-5085925c70d2.png)

# 여러 가지 IP 주소

IP주소는 약 2의 32승(43억개) 까지 존재할 수 있다. 하지만 어떤 주소나 마음대로 사용해도 좋은가 하면 그렇지 않다.
**사용 용도나 사용 장소에 따라 어디부터 어디까지를 어떻게 사용해야 하는지가 정해져 있다.**

IP주소는 사용 용도에 따라 클래스 A부터 클래스 E까지 5개의 주소 클래스로 나눌 수 있다. 그 중에서 일반적으로 사용하는 것은 클래스 A부터 크랠스 C까지로 컴퓨터에 설정하여 일대일 통신(유니캐스트)에서 사용한다. **이 3개의 클래스 차이는 네트워크 규격의 차이이다.** 클래스 A, B, C 순으로 규격이 작아진다.클래스 D, E는 특수한 용도로 사용하므로 일반적으로 사용하지 않는다. 주소 클래스는 32비트 중맨 처음 1~4비트로 분류한다. 이 비트에 따라서 사용할 수 있는 IP 주소의 범위가 필연적으로 정해져 있다.

![image](https://user-images.githubusercontent.com/41848169/148069176-58906dc4-d5ab-42fc-9c0f-421e29a5c4d8.png)

IP 주소는 사용 장소에 따라 **'글로벌 IP 주소'** 와 **'프라이빗 IP 주소'** 로 분류 할 수도 있다.
글로벌 IP주소는 인터넷에서 고유한 IP주소이다. ICANN(Internet Corporation for Assigned Names and Numbers)라는 민간 비영리 법인이 네트워크에서 고유한 값이 되도록 관리한다.
** 프라이빗 IP 주소는 조직이나 가정 등의 LAN에서 자유롭게 할당해도 좋은 IP 주소이다.** 클래스에 따라 다음과 같이 정해져 있다.
![image](https://user-images.githubusercontent.com/41848169/148069483-c2c72bee-c11b-4262-80a2-3c5164a9d2be.png)

# 라우팅

이더넷으로 만든 네트워크와 네트워크 연결할 때 사용하는 네트워크 기기가 '라우터'이다. 라우터는 미리 만들어 놓은 '라우팅 테이블' 이용하여 패킷을 전송한다. 라우터가 수행하는 패킷 전송을 라우팅(
경로 설정)이라고 한다. 라우팅 테이블은 '목적지 네트워크'와 목적지 네트워크로 가기 위해 보내야 할 곳의 IP 주소(넥스트 홉)으로 구성되어 있다. 라우터는 패킷을 받으면 패킷의 목적지 IP주소와 라우팅 테이블 목적지 네트워크를 대조한다. 목적지 IP 주소가 목적지 네티워크에 있으면 넷스트 홉의 IP주소로 패킷을 전송하고, 없는 경우에는 패킷을 파기한다.
![image](https://user-images.githubusercontent.com/41848169/148069798-fe6c6e2b-9d3d-431d-89c9-09eb31b079a0.png)

라우팅 테이블은 만드는 방법은 '정적 라우팅'과 '동적 라우팅'이 이싿.
정적 라웉닝은 수동으로 라우팅 테이블을 만드는 방법으로, 목적지 네늩워크와 넥스트 홉을 하나하나 설정하낟. 정적 라우팅은 모든 라우터에 대해 설정이 필요하지만 알기 쉬우며 관리하기 쉽기 때문에 소규모 네트워크 환경에서 




 
